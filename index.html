<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="theme-color" content="#4f5f31" />
    
    <!-- Cache optimization meta tags for SEO performance -->
    <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Resource hints for better caching and performance -->
    <link rel="dns-prefetch" href="//xcvlijchkmhjonhfildm.supabase.co">
    <link rel="dns-prefetch" href="//js.stripe.com">
    <link rel="dns-prefetch" href="//m.stripe.network">
    <link rel="preconnect" href="https://xcvlijchkmhjonhfildm.supabase.co" crossorigin>
    <link rel="preconnect" href="https://js.stripe.com" crossorigin>
    
    <!-- Critical CSS optimization for render blocking fix -->
    <script>
      (function() {
        // Create critical CSS immediately to prevent FOUC
        const criticalCSS = document.createElement('style');
        criticalCSS.id = 'critical-css';
        criticalCSS.textContent = `
          /* Enhanced Critical CSS for initial render - prevents FOUC */
          * { box-sizing: border-box; }
          body { margin: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; }
          #root { min-height: 100vh; }
          
          /* Critical layout classes */
          .container { max-width: 1200px; margin: 0 auto; padding: 0 1rem; }
          .flex { display: flex; }
          .grid { display: grid; }
          .hidden { display: none; }
          .block { display: block; }
          .relative { position: relative; }
          .absolute { position: absolute; }
          .fixed { position: fixed; }
          .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
          .z-50 { z-index: 50; }
          
          /* Critical spacing */
          .p-4 { padding: 1rem; }
          .py-16 { padding-top: 4rem; padding-bottom: 4rem; }
          .px-4 { padding-left: 1rem; padding-right: 1rem; }
          .mx-auto { margin-left: auto; margin-right: auto; }
          .mb-8 { margin-bottom: 2rem; }
          .gap-4 { gap: 1rem; }
          
          /* Critical colors */
          .bg-background { background-color: white; }
          .bg-stone-100 { background-color: rgb(245 245 244); }
          .text-stone-900 { color: rgb(28 25 23); }
          .text-white { color: white; }
          
          /* Critical animations */
          .transition-opacity { transition: opacity 0.3s; }
          .opacity-0 { opacity: 0; }
          .opacity-100 { opacity: 1; }
          .animate-spin { animation: spin 1s linear infinite; }
          @keyframes spin { to { transform: rotate(360deg); } }
          
          /* Critical responsive grid */
          .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
          @media (min-width: 768px) {
            .md\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
            .md\\:text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
          }
          
          /* Critical typography */
          .font-serif { font-family: "Playfair Display", Georgia, serif; }
          .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
          .text-center { text-align: center; }
          
          /* Critical image styles */
          img { max-width: 100%; height: auto; }
          .object-cover { object-fit: cover; }
          .w-full { width: 100%; }
          .h-full { height: 100%; }
          .aspect-square { aspect-ratio: 1 / 1; }
          .rounded-lg { border-radius: 0.5rem; }
          
          /* Hero section critical styles */
          .min-h-screen { min-height: 100vh; }
          .aspect-\\[4\\/3\\] { aspect-ratio: 4 / 3; }
          
          /* Navigation critical styles */
          .justify-between { justify-content: space-between; }
          .items-center { align-items: center; }
          .space-x-8 > :not([hidden]) ~ :not([hidden]) { margin-left: 2rem; }
        `;
        document.head.appendChild(criticalCSS);
        
        // Optimized CSS loading strategy to improve TTI
        let cssLoaded = false;
        const loadMainCSS = () => {
          if (cssLoaded) return;
          cssLoaded = true;
          
          const cssLink = document.createElement('link');
          cssLink.rel = 'stylesheet';
          cssLink.href = '/assets/index-CTRRF5Tz.css';
          cssLink.media = 'print'; // Load without blocking
          cssLink.onload = function() {
            this.media = 'all'; // Apply styles after load
            // Keep critical CSS for a bit longer to ensure smooth transition
            setTimeout(() => {
              const critical = document.getElementById('critical-css');
              if (critical && critical.parentNode) {
                critical.parentNode.removeChild(critical);
              }
            }, 200);
          };
          document.head.appendChild(cssLink);
        };
        
        // Aggressive deferring strategy for better TTI
        if (document.readyState === 'loading') {
          // Wait for DOM to be ready
          document.addEventListener('DOMContentLoaded', () => {
            // Use RAF to ensure we're not blocking painting
            requestAnimationFrame(() => {
              setTimeout(loadMainCSS, 0);
            });
          });
        } else {
          // Document already ready
          requestAnimationFrame(() => {
            setTimeout(loadMainCSS, 0);
          });
        }
        
        // Load on any interaction but prioritize page readiness
        const interactionEvents = ['scroll', 'mousedown', 'touchstart', 'keydown'];
        const loadOnInteraction = () => {
          loadMainCSS();
          interactionEvents.forEach(event => {
            document.removeEventListener(event, loadOnInteraction);
          });
        };
        
        interactionEvents.forEach(event => {
          document.addEventListener(event, loadOnInteraction, { once: true, passive: true });
        });
        
        // Absolute fallback - ensure CSS loads eventually
        setTimeout(loadMainCSS, 1000);
        
        // Fallback stylesheet for no-JS
        const noscriptFallback = document.createElement('noscript');
        noscriptFallback.innerHTML = '<link rel="stylesheet" href="/assets/index-CTRRF5Tz.css">';
        document.head.appendChild(noscriptFallback);
      })();
    </script>
    <link rel="manifest" href="/manifest.json" />
    <link rel="icon" href="/favicon.png" type="image/png" />
    
    <!-- Preload critical LCP image with highest priority -->
    <link rel="preload" href="/assets/images/home_page_image.webp" as="image" type="image/webp" fetchpriority="high" imagesizes="(max-width: 768px) 100vw, 632px">
    
    <title>Rif Raw Straw - Artisanat Berbère Authentique</title>
    <meta name="description" content="Découvrez notre collection unique d'accessoires berbères, confectionnés à la main par des artisans passionnés." />
    <meta name="author" content="Optimum Solutions Groupe by M. BEN-YAKOUB" />
    <meta name="generator" content="Optimum Solutions Groupe by M. BEN-YAKOUB" />

    <meta property="og:title" content="Rif Raw Straw - Artisanat Berbère Authentique" />
    <meta property="og:description" content="Découvrez notre collection unique d'accessoires berbères, confectionnés à la main par des artisans passionnés." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/assets/images/home_page_image.webp" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@rifrawstraw" />
    <meta name="twitter:image" content="/assets/images/home_page_image.webp" />
  </head>

  <body>
    <div id="root"></div>
    
    <!-- Optimized Service Worker registration for better TTI -->
    <script>
      // Defer service worker registration to not block TTI
      window.addEventListener('load', function() {
        // Additional delay to ensure TTI is not impacted
        setTimeout(function() {
          if ('serviceWorker' in navigator && 'caches' in window) {
            // Clean up old caches first
            caches.keys().then(function(names) {
              for (let name of names) {
                if (name.includes('v1') || name.includes('old')) {
                  caches.delete(name);
                }
              }
            });
            
            // Register service worker
            navigator.serviceWorker.register('/sw.js')
              .then(function(registration) {
                console.log('ServiceWorker registered');
              })
              .catch(function(error) {
                console.log('ServiceWorker registration failed');
              });
          }
        }, 1000); // Delay to ensure TTI is not blocked
      });
    </script>
    
    <!-- IMPORTANT: DO NOT REMOVE THIS SCRIPT TAG OR THIS VERY COMMENT! -->
    <!-- Google Analytics Configuration Override -->
    <script>
      // Override Google Analytics configuration to prevent Attribution Reporting API errors
      window.gtag = function() {
        // Override gtag to prevent attribution reporting API calls
        if (arguments[0] === 'config' && arguments[1]) {
          // Call original gtag but without attribution reporting
          const originalArgs = Array.from(arguments);
          if (originalArgs[2]) {
            // Remove attribution reporting related configs
            delete originalArgs[2]['attribution_reporting'];
            delete originalArgs[2]['enhanced_conversions'];
            delete originalArgs[2]['os_attribution'];
          }
        }
        // Call the original gtag function if it exists
        if (window.gtag_original) {
          return window.gtag_original.apply(this, arguments);
        }
      };
      
      // Backup original gtag if it gets loaded later
      Object.defineProperty(window, 'gtag_original', {
        configurable: true,
        writable: true,
        value: null
      });
      
      // Enhanced fetch interceptor with task scheduling for better TBT
      if ('fetch' in window) {
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
          const url = args[0];
          if (typeof url === 'string') {
            // Block analytics calls causing errors
            if (url.includes('privacy-sandbox/register') || 
                url.includes('register-os-conversion') ||
                url.includes('register-conversion')) {
              return Promise.resolve(new Response('{}', { status: 204 }));
            }
            // Block excessive Sentry requests (95% of them to reduce spam)
            if (url.includes('sentry.io') && Math.random() < 0.95) {
              return Promise.resolve(new Response('{}', { status: 204 }));
            }
          }
          
          // Schedule network requests to avoid blocking main thread
          return new Promise((resolve) => {
            const scheduleRequest = () => {
              originalFetch.apply(this, args).then(resolve).catch(resolve);
            };
            
            // Use MessageChannel for faster scheduling if available
            if (typeof MessageChannel !== 'undefined') {
              const channel = new MessageChannel();
              channel.port2.onmessage = scheduleRequest;
              channel.port1.postMessage(null);
            } else {
              setTimeout(scheduleRequest, 0);
            }
          });
        };
      }

      // Optimized postMessage handling to reduce TBT
      const originalPostMessage = window.postMessage;
      let postMessageCount = 0;
      const postMessageLimit = 10;
      const resetInterval = 1000; // 1 second
      
      window.postMessage = function(...args) {
        postMessageCount++;
        if (postMessageCount > postMessageLimit) {
          // Silently drop excessive postMessage calls
          return;
        }
        
        // Schedule postMessage to avoid blocking
        if (typeof MessageChannel !== 'undefined') {
          const channel = new MessageChannel();
          channel.port2.onmessage = () => originalPostMessage.apply(this, args);
          channel.port1.postMessage(null);
        } else {
          setTimeout(() => originalPostMessage.apply(this, args), 0);
        }
      };
      
      // Reset counter periodically
      setInterval(() => {
        postMessageCount = 0;
      }, resetInterval);

      // Suppress feature detection warnings
      const originalConsoleWarn = console.warn;
      console.warn = function(...args) {
        const message = args[0];
        if (typeof message === 'string' && 
            (message.includes('Unrecognized feature') || 
             message.includes('vr') || 
             message.includes('ambient-light-sensor') || 
             message.includes('battery'))) {
          // Suppress these warnings
          return;
        }
        return originalConsoleWarn.apply(this, args);
      };
    </script>
    <script>
      // Ultra-deferred loading of non-critical scripts for optimal TTI
      window.addEventListener('load', function() {
        // Wait for everything to settle before loading optional scripts
        setTimeout(function() {
          const shouldLoadGPTEngineer = window.location.search.includes('dev') || 
                                        window.location.hostname === 'localhost';
          if (shouldLoadGPTEngineer) {
            const script = document.createElement('script');
            script.src = 'https://cdn.gpteng.co/gptengineer.js';
            script.type = 'module';
            script.defer = true;
            document.head.appendChild(script);
          }
        }, 2000); // Significant delay to not impact TTI
      });
    </script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
